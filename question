react 中的key作用
    简单结构下不带key会就地复用，会更快 但会有副作用导致组建状态混乱
    key的作用为消除就地复用带来的副作用  在diff对比时更快的找到旧节点(不带key是遍历 带key是map)

['1', '2', '3'].map(parseInt) what & why ?
    1 NaN NaN
    '1' 0 十进制 1
    '2' 1 一进制 NaN
    '3' 2 二进制 NaN

let unary = fn => val => fn(val)
let parse = unary(parseInt)
console.log(['1.1', '2', '0.3'].map(parse))  // [1,2,0]

防抖跟节流?
 防抖 只会触发一次
 function debounce(method,delay){
    var timer = null
    return function (){
        var self = this
        var args = arguments
        timer && clearTimeout(timer)
        timer = setTimeout(function(){
            method.apply(self,args)
        },delay)
    }
 }
 节流 每搁一段时间触发一次
 function throttle(method,delay){
     return function (){
         var now = new Date()
         var self = this
         var args = arguments
         if(!start){
             start = new Date()
         }
         timer && clearTimeout(timer)
         if(now - start >= delay){
             method.apply(self,args)
         }else{
            timer = setTimeout(function () {
                loop.apply(self, args);
            }, 50);
         }
     }
 }

 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？
    Set 是以[value,value] 储存的 类似于数组，但成员是唯一且无序的，没有重复的值。 add delete has clear size  keys values entries 
    WeakSet 只能储存对象引用  add has delete
    Map  是以[key,value]储存的 是 值-值的对应 而对象是是将所有的key都转为字符串 是字符串-值得对应  set get delete has clear size  keys values entries 
    WeakMap 只接受对象作为键名（null除外） 防止内存泄露

介绍下深度优先遍历和广度优先遍历，如何实现？
    深度优先 对象深拷贝
    function deep(node,list=[]){
        if(node){
            list.push(node)
            for(let i = 0; i < node.children.length; i++){
                deep(node.children,list)
            }
        }else{
            return list
        }
    }
    广度优先
    function bfs(node){
        let result = []
        let stack = []
        if(node){
            stack.push(node)
            while(stack.length){
                let item = stack.shift()
                result.push(item)
                for(i = 0; i < item.children.length; i++){
                    stack.push(item.children[i])
                }
            }
        }
        return result
    }

ES5/ES6 的继承除了写法以外还有什么区别？
    继承的区别
    function father{}
    function son{}
    son.prototype = new father()
    son.prototype.constructor = father
    son.__proto__ == Function.prototype
    -----
    class father{}
    class son extends father{}
    son.__proto__ == father

    class 内部使用严格模式
    class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。
    const bar = new Bar(); // it's ok
        function Bar() {
        this.bar = 42;
    }

    const foo = new Foo(); // ReferenceError: Foo is not defined
    class Foo {
        constructor() {
            this.foo = 42;
        }
    }
    class 所有方法都是不可枚举的
    class 不携带new会报错
    class 不可在内部重写类名

setTimeout Promise Async/Await
    setTimeout 进入event loop 队列
    promise 进入主线程的微任务里
    async 返回promise 遇到await就等待返回 类似co genarator
    {
        console.log('start')
        let promise1 = new Promise(function (resolve) {
            console.log('promise1')
            resolve()
            console.log('promise1 end')
        }).then(function () {
            console.log('promise2')
        })
        setTimeout(function(){
            console.log('settimeout')
        })
        console.log('end')
    } 
    start--promise1--promise1 end--end--promise2--settimeout
    {
        async function async1(){
            console.log('async1 start');
            await async2();
            console.log('async1 end')
        }
        async function async2(){
            console.log('async2')
        }

        console.log('script start');
        async1();
        console.log('script end')
    }
    script start--async1 start--async2--script end--async1 end
    {
        setTimeout(() => console.log(1));
        setImmediate(() => console.log(2));
        process.nextTick(() => console.log(3));
        Promise.resolve().then(() => console.log(4));
        (() => console.log(5))();
    }
    5--3--4--1--2 
    {
        const fs = require('fs');
        const timeoutScheduled = Date.now();

        // 异步任务一：100ms 后执行的定时器
        setTimeout(() => {
            const delay = Date.now() - timeoutScheduled;
            console.log(`${delay}ms`);
        }, 100);

        // 异步任务二：文件读取后，有一个 200ms 的回调函数
        fs.readFile('test.js', () => {
            const startCallback = Date.now();
            while (Date.now() - startCallback < 200) {
                // 什么也不做
        }
        });
    }
    log(200+ms)

Async/Await 如何通过同步的方式实现异步
    类似co genarator

异步问题
    {
        async function async1() {
            console.log('async1 start');
            await async2();
            console.log('async1 end');
        }
        async function async2() {
             new Promise(function(resolve) {
                console.log('promise1');
                resolve();
            }).then(function() {
                console.log('promise2');
                });
        }
        console.log('script start');
        setTimeout(function() {
            console.log('setTimeout');
        }, 0)
        async1();
        new Promise(function(resolve) {
            console.log('promise3');
            resolve();
        }).then(function() {
            console.log('promise4');
        });
        console.log('script end');
    }
    script start--async1 start--promise1--promise3--script end--promise2--assync1 end--promise4-setTimeout
    会把await后面的放入微任务队列 但promise中的resulve()后面的是属于宏任务
    宏任务 script start--async1 start--promise1--promise3--script end
    微任务 promise2--assync1 end--promise4

var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组
    [...new Set(arr.flat(Infinity))].sort((a,b)=>a-b)
    数组扁平化
    arr.flat
    arr.toString().split(',')
    function flatDeep(arr,deep=1){
        return deep > 0 ? arr.reduce((acc,val) => acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), []):arr.slice()
    }
    堆栈
    function flat(arr){
        const stack=[...arr]
        const res = []
        while(stack.length){
            let item=stack.pop()
            if(Array.isArray(item)){
                stack.push(item)
            }else{
                res.push(item)
            }
        }
        return res
    }

JS 异步解决方案的发展历程以及优缺点
    回调函数  promise(链式调用 无法取消)  genarater async/await
    let a = 0
    let b = async () => {
    a = a + await 10
    console.log('2', a) 
    }
    b()
    a++
    console.log('1', a) 
     1 1
     2 10

Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？
    构造函数同步 then放到微任务里 等待主线程任务执行完后再执行

如何实现一个 new
    function _new(fn,...args){
        // 创建一个新对象
        // 对象的__proto__指向构建函数的prototype
        const newObj = Object.creat(fn.prototype)
          // 执行代码时候, 绑定this指向新的对象
        const res = fn.apply(newObj,args)
         // 如果构造函数有返回值, 返回构造函数的值, 否则返回新对象
        return Object.prototype.toString.call(res) === '[object Object]' ? res : newObj
    }

简单讲解一下http2的多路复用
    http1 每次请求都会建立一个http连接 
    http2 的多路复用同域名下所有的通信都在单个连接上完成 
    http2中的帧跟流 
    帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
    多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。
    通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

谈谈你对 TCP 三次握手和四次挥手的理解
    三次握手
    为了保证客户端 服务端 均让对方知道收发能力没问题
    为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认
    四次挥手
    A=>B
    B=>A
    B=>A
    A=>B
    当A告诉B，要关闭的时候，B可能还有一个包正在传输中，所以是等正在传输中的这个包传输完毕之后再回复A一下，
    由于TCP连接是全双工的，因此每个方向都必须单独进行关闭，所以即使没有最后一个包，也需要先回复断开连接的请求，然后再发送关闭请求

React 中 setState 什么时候是同步的，什么时候是异步的？
    在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，
    除此之外的setState调用会同步执行this.state。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事
    件处理函数，还有通过setTimeout/setInterval产生的异步调用。
    **原因：**在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列
    中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数
    batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个
    batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。

 this.setState({val: this.state.val + 1});
    console.log(this.state.val);    // 第 1 次 log

    this.setState({val: this.state.val + 1});
    console.log(this.state.val);    // 第 2 次 log

    setTimeout(() => {
      this.setState({val: this.state.val + 1});
      console.log(this.state.val);  // 第 3 次 log

      this.setState({val: this.state.val + 1});
      console.log(this.state.val);  // 第 4 次 log
    }, 0);

    react中 0 0 2 3
    preact中 1 2 3 4

介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？
    根据package.json里的dependencies和devdependencies确定首层依赖
    递归获取模块信息
    扁平化去除重复模块 重复模块有兼容版本就是用兼容版本
    向registry查询下载地址
    下载压缩包放到.npm 里
    解压到node_modules

Object.prototype.toString.call() 、 instanceof 以及 Array.isArray() 区别
    toString 是Array.isArray的polyfill
    instanceof是根据原型链来判断的 会判断这个对象的原型链上是否会找到对应的 Array 的原型 会有iframe 不一致的问题

介绍下重绘和回流（Repaint & Reflow），以及如何进行优化
    repaint 不会影响布局的 改变颜色
    reflow 影响页面布局的 或者获取布局信息（width offsetwidth scrolltop getcomputedstyle()） 
    因为浏览器通过队列机制来批量更新 会把待修改的放在队列中 一个更新周期(16.6ms)才会更新 当获取布局信息时 队列中有
    些操作可能会影响要获取的布局信息 所以会强制触发一次回流
    优化
    能用重绘就重绘
    少用.style.xx  合并为 el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;';
    避免频繁操作样式 dom 读取布局信息  
    使用document fragment

介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景
    观察者模式是观察者跟被观察者直接相关联的 addeventlistener 就属于观察者模式 js跟dom绑定 vue的双向绑定
    class Subject{
    constructor(){
        this.subs = [];
    }
    addSub(sub){
        this.subs.push(sub);
    }
    notify(){
        this.subs.forEach(sub=> {
            sub.update();
            });
        }
    }
    class Observer{
        update(){
            console.log('update');
        }
    }
    let subject = new Subject();
    let ob = new Observer();
    //目标添加观察者了
    subject.addSub(ob);
    //目标发布消息调用观察者的更新方法了
    subject.notify();   //update
    订阅-发布模式 比观察者模式中间多了一层对象 用来订阅 发布 event.on event.emit 通过event来发布订阅 
    订阅者 发布者不知晓对方的存在
    var pubsub = (()=>{
    var topics = {};
    function subscribe(topic,fn){
        if(!topics[topic]){
        topics[topic] = [];  
        }
        topics[topic].push(fn);
    }
    function publish(topic,...args){
        if(!topics[topic])
        return;
        for(let fn of topics[topic]){
        fn(...args);  
        }
    }
    return {
        subscribe,
        publish
    }
    })()
    pubsub.subscribe('test',function(a,b){  //订阅者A订阅了test事件
    console.log(a,b);    
    });
    pubsub.publish('test','123','HH'); //发布者发布了了test事件

redux跟vuex设计思想
    相同点 都是处理全局状态的库 全局state=>dispatch(action)=>reducer=>新state
    不同点 异步处理不同 redux需要通过中间件

浏览器和Node 事件循环的区别
    差异体现在nodeV10之前
    浏览器是执行完一个宏任务就会去清空微任务队列；node则是将同源的宏任务队列执行完毕后再去清空微任务队列