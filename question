react 中的key作用
    简单结构下不带key会就地复用，会更快 但会有副作用导致组建状态混乱
    key的作用为消除就地复用带来的副作用  在diff对比时更快的找到旧节点(不带key是遍历 带key是map)

['1', '2', '3'].map(parseInt) what & why ?
    1 NaN NaN
    '1' 0 十进制 1
    '2' 1 一进制 NaN
    '3' 2 二进制 NaN

let unary = fn => val => fn(val)
let parse = unary(parseInt)
console.log(['1.1', '2', '0.3'].map(parse))  // [1,2,0]

防抖跟节流?
 防抖 只会触发一次
 function debounce(method,delay){
    var timer = null
    return function (){
        var self = this
        var args = arguments
        timer && clearTimeout(timer)
        timer = setTimeout(function(){
            method.apply(self,args)
        },delay)
    }
 }
 节流 每搁一段时间触发一次
 function throttle(method,delay){
     return function (){
         var now = new Date()
         var self = this
         var args = arguments
         if(!start){
             start = new Date()
         }
         timer && clearTimeout(timer)
         if(now - start >= delay){
             method.apply(self,args)
         }else{
            timer = setTimeout(function () {
                loop.apply(self, args);
            }, 50);
         }
     }
 }

 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？
    Set 是以[value,value] 储存的 类似于数组，但成员是唯一且无序的，没有重复的值。 add delete has clear size  keys values entries 
    WeakSet 只能储存对象引用  add has delete
    Map  是以[key,value]储存的 是 值-值的对应 而对象是是将所有的key都转为字符串 是字符串-值得对应  set get delete has clear size  keys values entries 
    WeakMap 只接受对象作为键名（null除外） 防止内存泄露

介绍下深度优先遍历和广度优先遍历，如何实现？
    深度优先 对象深拷贝
    function deep(node,list=[]){
        if(node){
            list.push(node)
            for(let i = 0; i < node.children.length; i++){
                deep(node.children,list)
            }
        }else{
            return list
        }
    }
    广度优先
    function bfs(node){
        let result = []
        let stack = []
        if(node){
            stack.push(node)
            while(stack.length){
                let item = stack.shift()
                result.push(item)
                for(i = 0; i < item.children.length; i++){
                    stack.push(item.children[i])
                }
            }
        }
        return result
    }

ES5/ES6 的继承除了写法以外还有什么区别？
    继承的区别
    function father{}
    function son{}
    son.prototype = new father()
    son.prototype.constructor = father
    son.__proto__ == Function.prototype
    -----
    class father{}
    class son extends father{}
    son.__proto__ == father

    class 内部使用严格模式
    class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。
    const bar = new Bar(); // it's ok
        function Bar() {
        this.bar = 42;
    }

    const foo = new Foo(); // ReferenceError: Foo is not defined
    class Foo {
        constructor() {
            this.foo = 42;
        }
    }
    class 所有方法都是不可枚举的
    class 不携带new会报错
    class 不可在内部重写类名

setTimeout Promise Async/Await
    setTimeout 进入event loop 队列
    promise 进入主线程的微任务里
    async 返回promise 遇到await就等待返回 类似co genarator
    {
        console.log('start')
        let promise1 = new Promise(function (resolve) {
            console.log('promise1')
            resolve()
            console.log('promise1 end')
        }).then(function () {
            console.log('promise2')
        })
        setTimeout(function(){
            console.log('settimeout')
        })
        console.log('end')
    } 
    start--promise1--promise1 end--end--promise2--settimeout
    {
        async function async1(){
            console.log('async1 start');
            await async2();
            console.log('async1 end')
        }
        async function async2(){
            console.log('async2')
        }

        console.log('script start');
        async1();
        console.log('script end')
    }
    script start--async1 start--async2--script end--async1 end
    {
        setTimeout(() => console.log(1));
        setImmediate(() => console.log(2));
        process.nextTick(() => console.log(3));
        Promise.resolve().then(() => console.log(4));
        (() => console.log(5))();
    }
    5--3--4--1--2 
    {
        const fs = require('fs');
        const timeoutScheduled = Date.now();

        // 异步任务一：100ms 后执行的定时器
        setTimeout(() => {
            const delay = Date.now() - timeoutScheduled;
            console.log(`${delay}ms`);
        }, 100);

        // 异步任务二：文件读取后，有一个 200ms 的回调函数
        fs.readFile('test.js', () => {
            const startCallback = Date.now();
            while (Date.now() - startCallback < 200) {
                // 什么也不做
        }
        });
    }
    log(200+ms)

Async/Await 如何通过同步的方式实现异步
    类似co genarator

异步问题
    {
        async function async1() {
            console.log('async1 start');
            await async2();
            console.log('async1 end');
        }
        async function async2() {
             new Promise(function(resolve) {
                console.log('promise1');
                resolve();
            }).then(function() {
                console.log('promise2');
                });
        }
        console.log('script start');
        setTimeout(function() {
            console.log('setTimeout');
        }, 0)
        async1();
        new Promise(function(resolve) {
            console.log('promise3');
            resolve();
        }).then(function() {
            console.log('promise4');
        });
        console.log('script end');
    }
    script start--async1 start--promise1--promise3--script end--promise2--assync1 end--promise4-setTimeout
    会把await后面的放入微任务队列 但promise中的resulve()后面的是属于宏任务
    宏任务 script start--async1 start--promise1--promise3--script end
    微任务 promise2--assync1 end--promise4

var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组
    [...new Set(arr.flat(Infinity))].sort((a,b)=>a-b)
    数组扁平化
    arr.flat
    arr.toString().split(',')
    function flat(arr,deep=1){
        return deep > 0 ? arr.reduce((acc,val) => acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), []):arr.slice()
    }
    堆栈
    function flat(arr){
        const stack=[...arr]
        const res = []
        while(stack.length){
            let item=stack.pop()
            if(Array.isArray(item)){
                stack.push(item)
            }else{
                res.push(item)
            }
        }
        return res
    }

